-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/imustafin/hooridor#readme</a>
@package hooridor
@version 0.1.0.0

module Hooridor.Ai.AStar
data AStar a c
AStar :: !(HashSet a) -> !(HashPSQ a c ()) -> !(HashMap a c) -> !(HashMap a c) -> !(HashMap a a) -> !(Maybe a) -> AStar a c
[visited] :: AStar a c -> !(HashSet a)
[waiting] :: AStar a c -> !(HashPSQ a c ())
[score] :: AStar a c -> !(HashMap a c)
[memoHeur] :: AStar a c -> !(HashMap a c)
[cameFrom] :: AStar a c -> !(HashMap a a)
[end] :: AStar a c -> !(Maybe a)
aStarInit :: (Hashable k, Ord k, Ord c, Num c) => k -> AStar k c
runAStar :: (Hashable a, Ord a, Ord c, Num c) => (a -> HashSet a) -> (a -> a -> c) -> (a -> c) -> (a -> Bool) -> a -> AStar a c

-- | This function computes an optimal (minimal distance) path through a
--   graph in a best-first fashion, starting from a given starting point.
aStar :: (Hashable a, Ord a, Ord c, Num c) => (a -> HashSet a) -> (a -> a -> c) -> (a -> c) -> (a -> Bool) -> a -> Maybe [a]
instance (GHC.Show.Show a, GHC.Show.Show c) => GHC.Show.Show (Hooridor.Ai.AStar.AStar a c)

module Hooridor.Core
type Cell = (Int, Int)
data PlayerColor
Green :: PlayerColor
Yellow :: PlayerColor
Red :: PlayerColor
Orange :: PlayerColor

-- | Who controls the player
data Inteligence

-- | AI algorithm with this depth
AI :: Int -> Inteligence

-- | Human controls from GUI
Human :: Inteligence
data Player
Player :: PlayerColor -> Cell -> Int -> Inteligence -> Player
[pcolor] :: Player -> PlayerColor
[pos] :: Player -> Cell
[wallsLeft] :: Player -> Int
[inteligence] :: Player -> Inteligence
data Turn
MakeMove :: Cell -> Turn
PutWall :: Wall -> Turn
type WallPart = (Cell, Cell)
type Wall = (WallPart, WallPart)
data GameState
GameState :: [Player] -> [Wall] -> GameState
[playerList] :: GameState -> [Player]
[walls] :: GameState -> [Wall]
minRow :: Int
minCol :: Int
maxRow :: Int
maxCol :: Int
size :: Int
cellInBound :: Cell -> Bool
transposeWall :: Wall -> Wall
wallPartEq :: WallPart -> WallPart -> Bool
wallEq :: Wall -> Wall -> Bool
hasWallPart :: WallPart -> Wall -> Bool
areAdjacentCells :: Cell -> Cell -> Bool
isValidWallPart :: WallPart -> Bool
isValidWall :: Wall -> Bool
notInWall :: WallPart -> [Wall] -> Bool
currentPlayer :: GameState -> Player
oneStep :: Cell -> Cell -> [Wall] -> Bool

-- | Perform one turn and give turn order to next player
takeTurn :: Turn -> GameState -> GameState

-- | Checks if Turn is valid
validTurn :: Turn -> GameState -> Bool

-- | Generate new state from movement, but don't pass turn
move :: GameState -> Turn -> GameState

-- | Get all possible moves
validMoves :: GameState -> [Turn]
isWinner :: Player -> Bool

-- | Check if all players can reach final state
playersCanReachGoal :: GameState -> Bool

-- | Check if player can reach final state
playerCanReachGoal :: GameState -> Player -> Bool
playerCanReachGoalOld :: GameState -> Player -> Bool

-- | Give turn to some player
giveTurn :: GameState -> Player -> GameState

-- | In this GameState this Player standing on this Cell | to what cells
--   can go in one step
availablePositions :: GameState -> Player -> Cell -> [Cell]

-- | Make a state where it is this player on given cell an it's his/her
--   turn to move
putPlayerOn :: GameState -> Player -> Cell -> GameState

-- | Get shortest path to victory of current player
getShortestPath :: GameState -> Maybe [GameState]

-- | Winner in this game state, if there is one.
winner :: GameState -> Maybe Player
defaultWalls :: Int

-- | Initial state for a 2-player game, where the second is an AI algorithm
--   with a given depth.
initialStateAi :: Int -> GameState
initialState :: Int -> GameState
instance GHC.Generics.Generic Hooridor.Core.GameState
instance GHC.Classes.Ord Hooridor.Core.GameState
instance GHC.Show.Show Hooridor.Core.GameState
instance GHC.Classes.Eq Hooridor.Core.GameState
instance GHC.Show.Show Hooridor.Core.Turn
instance GHC.Classes.Ord Hooridor.Core.Player
instance GHC.Show.Show Hooridor.Core.Player
instance GHC.Classes.Eq Hooridor.Core.Player
instance GHC.Classes.Ord Hooridor.Core.Inteligence
instance GHC.Show.Show Hooridor.Core.Inteligence
instance GHC.Classes.Eq Hooridor.Core.Inteligence
instance GHC.Generics.Generic Hooridor.Core.PlayerColor
instance GHC.Classes.Ord Hooridor.Core.PlayerColor
instance GHC.Show.Show Hooridor.Core.PlayerColor
instance GHC.Enum.Enum Hooridor.Core.PlayerColor
instance GHC.Classes.Eq Hooridor.Core.PlayerColor
instance Data.Hashable.Class.Hashable Hooridor.Core.GameState
instance Data.Hashable.Class.Hashable Hooridor.Core.Player
instance Data.Hashable.Class.Hashable Hooridor.Core.PlayerColor

module Hooridor.Ai.Trees
type Score = Int
data StateTree v
StateNode :: v -> [(Turn, StateTree v)] -> StateTree v
data ScoreTree v
Node :: [(Turn, ScoreTree v)] -> ScoreTree v
Leaf :: v -> ScoreTree v
toLeafValueTree :: StateTree v -> ScoreTree v
instance GHC.Show.Show v => GHC.Show.Show (Hooridor.Ai.Trees.ScoreTree v)
instance GHC.Show.Show v => GHC.Show.Show (Hooridor.Ai.Trees.StateTree v)
instance Data.Foldable.Foldable Hooridor.Ai.Trees.ScoreTree
instance Data.Foldable.Foldable Hooridor.Ai.Trees.StateTree
instance GHC.Base.Functor Hooridor.Ai.Trees.StateTree

module Hooridor.Ai.MinMax

-- | Given some scoretree find turn which leads to minimum value
minMaxMinimize :: ScoreTree Score -> (Score, Maybe Turn)
maxInt :: Int

-- | Given some ScoreTree find turn which leads to maximum value
minMaxMaximize :: ScoreTree Score -> (Score, Maybe Turn)

module Hooridor.Ai.Helper

-- | Generate all possible turns for current player
allTurns :: GameState -> [Turn]

-- | Generate all possible wall placement turns
generateWalls :: GameState -> [Turn]

-- | Check if turn is valid, but don't use
validTurnBot :: Turn -> GameState -> Bool
board :: [Cell]

-- | Generate all possible wall parts given cell
generatePart :: Cell -> [WallPart]

-- | Generate all possible wall given wall part
generateWall :: WallPart -> Wall

module Hooridor.Ai.AlphaBeta
alphaBetaMaximize :: ScoreTree Score -> (Score, Maybe Turn)
alphaBetaMinimize :: ScoreTree Score -> (Score, Maybe Turn)

module Hooridor.Ai

-- | AI algorithm move with this depth of analysis.
aiPlayer :: Int -> GameState -> GameState

-- | Generate gameState tree from starting state.
generateStateTree :: GameState -> StateTree GameState

-- | Prune tree, because we don't want to evaluate all states.
prune :: Int -> StateTree s -> StateTree s

-- | Score gamestate for current player.
score :: GameState -> Score
scoreWithTrace :: GameState -> Score

module Hooridor.Gui.Types
type Renderer w = w -> Picture
type Handler w = Event -> w -> w
type Updater w = Float -> w -> w
type PlayType w = Display -> Color -> Int -> w -> Renderer w -> Handler w -> Updater w -> IO ()

module Hooridor.Gui.GameModeMenu

-- | Add AI selection menu to a game.
withGameModeMenu :: (GMMenuResult -> a) -> PlayType (GMMenu a) -> Display -> Color -> Int -> (Renderer a) -> (Handler a) -> (Updater a) -> IO ()

-- | Options which can be selected in this menu.
data GMMenuResult

-- | No AI players, no networking, 2 to 4 players
LocalGame :: Int -> GMMenuResult

-- | Easy AI player
EasyAi :: GMMenuResult

-- | Hard AI player
HardAi :: GMMenuResult
instance GHC.Show.Show Hooridor.Gui.GameModeMenu.GMMenuResult

module Hooridor.Gui

-- | State of the GUI: current GameState and additional decoration to draw.
data GuiState
GuiState :: GameState -> Picture -> GuiState

-- | Board objects that can be pointed at by a mouse.
data BoardObject
BoardCell :: Cell -> BoardObject
BoardWall :: Wall -> BoardObject

-- | Default Display to draw the game in.
window :: Display

-- | Default window background color.
background :: Color

-- | Default game frames per second value.
fps :: Int

-- | Display color of normal cells
normalCellColor :: Color

-- | Display color of walls
normalWallColor :: Color

-- | Display color of PlayerColors
colorPlayer :: PlayerColor -> Color

-- | Side of square cells in pixels.
cellSize :: Int

-- | Radius of the player icon
playerRadius :: Float

-- | Free space between cells in pixels.
cellMargin :: Int

-- | Distance between sides of two adjacent cells.
--   
--   Equal to <a>cellSize</a> plus <a>cellMargin</a>: prop&gt; cellSize +
--   cellMargin = cellSizeAndMargin
cellSizeAndMargin :: Int

-- | Center of the Cell drawn on the screen.
cellCenter :: Cell -> Point

-- | WallPart center coordinates.
wallPartCenter :: WallPart -> Point

-- | What board object is drawn at this point.
pointingAt :: Point -> Maybe BoardObject

-- | Response to events.
handleEvents :: Event -> GuiState -> GuiState

-- | Player icon, not translated.
playerIcon :: Player -> Picture

-- | Player icon translated to the cell position.
drawPlayer :: Player -> Picture

-- | Colored cell translated to the cell position.
drawCell :: Cell -> Color -> Picture

-- | Cell with the default color translated to the cell position.
drawDefaultCell :: Cell -> Picture

-- | Cell highlighted for this player and translated to the cell position.
highlightCell :: Cell -> Player -> Picture

-- | The point between two points.
meanPoint :: Point -> Point -> Point

-- | Draw a wall part with this color, translated to the correct position.
drawWallPart :: WallPart -> Color -> Picture

-- | Draw wall with this cololr, translated to the correct position.
drawWall :: Color -> Wall -> Picture

-- | Draw a wall hint, translated to the correct position.
wallHint :: Wall -> Player -> Picture

-- | Draw all cells normal, translated to the correct positions.
drawBoard :: Picture

-- | Draw victory screen for this player.
drawVictoryScreen :: Player -> Picture

-- | Picture telling how many walls this player has, translated on top of
--   the board.
currentPlayerIndicator :: Player -> Picture

-- | Draw current game state
render :: GuiState -> Picture

-- | Create new GuiState with this number of players.
initiateGame :: GMMenuResult -> GuiState

-- | Update per time (nothing updates).
update :: Float -> GuiState -> GuiState

-- | Run the game starting with the menus.
runGui :: IO ()
instance GHC.Show.Show Hooridor.Gui.BoardObject

module Hooridor
run :: IO ()
testAI :: IO ()
